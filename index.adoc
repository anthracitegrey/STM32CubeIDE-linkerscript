Understanding linkerscript.ld
=============================

:bmas: https://www.embedded.com/building-bare-metal-arm-systems-with-gnu-part-3/[[bmas]]
:ugls: https://www.silabs.com/community/mcu/32-bit/knowledge-base.entry.html/2018/12/06/understand_the_gnul-PTm6[[ugls]]
:usld: https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html#TOC16[[usld]]
:vgdb: https://visualgdb.com/tutorials/arm/linkerscripts/[[vgdb]]
:stov: https://stackoverflow.com/questions/40532180/understanding-the-linkerscript-for-an-arm-cortex-m-microcontroller[[stov]]
:eecs: https://www.eecs.umich.edu/courses/eecs373/readings/Linker.pdf[[eecs]]
:cppe: https://bitbashing.io/embedded-cpp.html[[cppe]]
:pfr7: https://www.pomad.fr/node/7/[[pfr7]]


Purpose
-------
I am documenting here the taking apart of "STM32F302R8TX_FLASH.ld", auto-generated by STM32CubeIDE for NUCLEO-F308R8 board.

Entry point
-----------

----
/* Entry Point */
ENTRY(Reset_Handler)
----

`ENTRY` explicitly specifies the first instruction to execute in a program {bmas}.

Heap and stack global symbols
-----------------------------

----
/* Highest address of the user mode stack */
_estack = ORIGIN(RAM) + LENGTH(RAM);	/* end of "RAM" Ram type memory */

_Min_Heap_Size = 0x200;	/* required amount of heap  */
_Min_Stack_Size = 0x400;	/* required amount of stack */
----

Looks like storing intermediate results of calculations in global symbols. The .map file shows:

----
                0x0000000020004000                _estack = (ORIGIN (RAM) + LENGTH (RAM))
                0x0000000000000200                _Min_Heap_Size = 0x200
                0x0000000000000400                _Min_Stack_Size = 0x400
----

`_estack` is used in `startup_stm32f302r8tx.s`:

----
  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
  mov   sp, r0          /* set stack pointer */
. . .
----

Memory regions
--------------

----
/* Memories definition */
MEMORY
{
  RAM	(xrw)	: ORIGIN = 0x20000000,	LENGTH = 16K
  ROM	(rx)	: ORIGIN = 0x8000000,	LENGTH = 64K
}
----

The `MEMORY` command describes the location and size of memory regions in the target. Each linker script can only have at most one `MEMORY` command, with nay number of regions within it {ugls}. Now that regions `RAM` and `ROM` are defined, coming sections can be assigned by `>` to them.

.Attributes {usld}
[%autowidth]
|=======================
|R|Read-only sections
|W|Read/write sections
|X|Sections containing executable code
|A|Allocated sections
|I|Initialized sections
|L|Same as I
|!|Invert the sense of any of the following attributes
|=======================

The .map file shows then:
----
Memory Configuration

Name             Origin             Length             Attributes
RAM              0x0000000020000000 0x0000000000004000 xrw
ROM              0x0000000008000000 0x0000000000010000 xr
*default*        0x0000000000000000 0xffffffffffffffff
----

----
/* Sections */
SECTIONS
{
----

The https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html#SEC17[`SECTIONS`] command controls exactly where input sections are placed into output sections, their order in the output file, and to which output sections they are allocated.

You may use at most one `SECTIONS` command in a script file, but you can have as many statements within it as you wish. Statements within the `SECTIONS` command can do one of three things:

- define the entry point;
- assign a value to a symbol;
- describe the placement of a named output section, and which input sections go into it.

Interrupt vectors
-----------------

----
  /* The startup code into "ROM" Rom type memory */
  .isr_vector :
  {
    . = ALIGN(4);
    KEEP(*(.isr_vector)) /* Startup code */
    . = ALIGN(4);
  } >ROM
----

The first section going into the FLASH memory is `.isr_vector` {vgdb}

The special linker variable dot `.` always contains the current https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html#SEC10[output location counter]. Since the `.` always refers to a location in an output section, it must always appear in an expression within a SECTIONS command. The `.` symbol may appear anywhere that an ordinary symbol is allowed in an expression, but its assignments have a side effect. Assigning a value to the `.` symbol will cause the location counter to be moved. This may be used to create holes in the output section. The location counter may never be moved backwards.

The https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html#SEC14[arithmetic function] `ALIGN(exp)` returns the result of the current location counter `.` aligned to the next exp boundary. `exp` must be an expression whose value is a power of two.

The `KEEP()` construct forces the linker to keep the sections in the final executable file even if they are not referenced by any other code {vgdb}.

`*` before the parenthesized input-file section list refers to _all_ files from the ld command line. (See https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html#SEC19[Section placement])

`>` https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html#SEC21[assigns] the secion to a region, defined by `MEMORY` command above.

The .map file shows:
----
.isr_vector     0x0000000008000000      0x188
                0x0000000008000000                . = ALIGN (0x4)
 *(.isr_vector)
 .isr_vector    0x0000000008000000      0x188 Startup/startup_stm32f302r8tx.o
                0x0000000008000000                g_pfnVectors
                0x0000000008000188                . = ALIGN (0x4)
----

0x8000000 ist the start of ROM memory region.

Program code
------------

----
  /* The program code and other data into "ROM" Rom type memory */
  .text :
  {
    . = ALIGN(4);
    *(.text)           /* .text sections (code) */
    *(.text*)          /* .text* sections (code) */
    *(.glue_7)         /* glue arm to thumb code */
    *(.glue_7t)        /* glue thumb to arm code */
    *(.eh_frame)

    KEEP (*(.init))
    KEEP (*(.fini))

    . = ALIGN(4);
    _etext = .;        /* define a global symbols at end of code */
  } >ROM
----

I can't find `._etext` anywhere else.

.rodata
----
  /* Constant data into "ROM" Rom type memory */
  .rodata :
  {
    . = ALIGN(4);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
    . = ALIGN(4);
  } >ROM
----

Unwinding (exception handling)
-------------------------------

----
  .ARM.extab   : {
    . = ALIGN(4);
    *(.ARM.extab* .gnu.linkonce.armextab.*)
    . = ALIGN(4);
  } >ROM

  .ARM : {
    . = ALIGN(4);
    __exidx_start = .;
    *(.ARM.exidx*)
    __exidx_end = .;
    . = ALIGN(4);
  } >ROM
----

`.ARM.extab` and `.ARM.exidx` are related to unwinding. {stov}

preinit_array
-------------

----
  .preinit_array     :
  {
    . = ALIGN(4);
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array*))
    PROVIDE_HIDDEN (__preinit_array_end = .);
    . = ALIGN(4);
  } >ROM
----

The `PROVIDE` keyword may be used todefine a symbol, such as ‘etext’, only if it is referenced but not defined (yet). The syntax is `PROVIDE(symbol=expression)`.
If the program defines `__preinit_array_start`, the linker will silently use the definition in the program. If the program references `__preinit_array_start` but does not define it, the linker will use the definition in the linker script. {eecs}

Constructors and destructors
-----------------------------

----
  .init_array :
  {
    . = ALIGN(4);
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array*))
    PROVIDE_HIDDEN (__init_array_end = .);
    . = ALIGN(4);
  } >ROM

  .fini_array :
  {
    . = ALIGN(4);
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT(.fini_array.*)))
    KEEP (*(.fini_array*))
    PROVIDE_HIDDEN (__fini_array_end = .);
    . = ALIGN(4);
  } >ROM
----

GCC groups the constructors into an array of function pointers under the symbol `.init_array`. While C++ runtime normally guarantees that all global (or file-local) objects are constructed before entering `main()`, but in an embedded environment, we must call the constructors ourselves, like so. Depending on where we call it (After hardware initialization? After RTOS setup, but before your tasks begin executing? In the first RTOS task?), it may be prudent to ensure these constructors don’t make OS calls or modify hardware state {cppe}

[source,c]
----
static void callConstructors()
{
    // Start and end points of the constructor list,
    // defined by the linker script.
    extern void (*__init_array_start)();
    extern void (*__init_array_end)();

    // Call each function in the list.
    // We have to take the address of the symbols, as __init_array_start *is*
    // the first function pointer, not the address of it.
    for (void (**p)() = &__init_array_start; p < &__init_array_end; ++p) {
        (*p)();
    }
}
----

The `.fini_array` is an array of functions that will be called on destruction (https://stackoverflow.com/questions/15265295/understanding-the-libc-init-array[SO])

Initialized variables
---------------------

`.data` Refers to ‘initialized variables’. Those variables have reserved location in RAM memory and their initial value is stored in the FLASH memory. In short, an initialized variable occupies 2x its own size (one in RAM, one in FLASH). {pfr7}
----
  /* Used by the startup to initialize data */
  _sidata = LOADADDR(.data);

  /* Initialized data sections into "RAM" Ram type memory */
  .data :
  {
    . = ALIGN(4);
    _sdata = .;        /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */

    . = ALIGN(4);
    _edata = .;        /* define a global symbol at data end */

  } >RAM AT> ROM
----

Every loadable or allocatable output section has two addresses. The first is the _VMA_, orvirtual memory address. This is the address the section will have when the output file is run. The second is the _LMA_, or load memory address. This is the address at which thesection will be loaded.  In most cases the two addresses will be the same.  An example ofwhen they might be different is when a data section is loaded into ROM, and then copiedinto  RAM  when  the  program  starts  up  (this  technique  is  often  used  to  initialize  globalvariables in a ROM based system). In this case the ROM address would be the LMA, andthe RAM address would be the VMA.

`LOADADDR(section)` returns the absolute LMA of the named section. This is normally the same as ADDR, but it may be different if the `AT` attribute is used in the output section definition. {eecs} https://sourceware.org/binutils/docs/ld/Output-Section-LMA.html[sourceware]

`_sidata`, `_sdata`, `_edata` are used in the memory initialization loop in `Reset_Handler` in `startup_stm32f302r8tx.s`:

----
/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
  ldr r1, =_edata
  ldr r2, =_sidata
  movs r3, #0
  b LoopCopyDataInit
. . .
----

`.data` (twice, once in ROM and once in RAM) is the place where global variables initialazed to non-zero value appear:

[source,c]
----
uint8_t state = 123;
int main(void)
{ . . .
----

Memory Details view in Eclipse shows this nicely. When initialazied to zero (`uint8_t state = 123;`), it's no longer in `.data` but in `.bss` (RAM only).

Uninitialized (zero-initialized) variables
------------------------------------------

`.bss` Refers to "uninitialized variables". Those variables have reserved locations in RAM memory. {pfr7} Historically (1950) `.bss` meant "Block Started by Symbol". Some people like to remember it as "Better Save Space". A well-written startup code must fill with zeros the `.bss` segment in order to reset all the ‘uninitialized’ variables (failing to do so means being not compliant to http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1570.pdf[C standard]). For this, it needs to know where the `.bss` is in RAM.

----
  /* Uninitialized data section into "RAM" Ram type memory */
  . = ALIGN(4);
  .bss :
  {
    /* This is used by the startup in order to initialize the .bss section */
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;
    *(.bss)
    *(.bss*)
    *(COMMON)

    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss;
  } >RAM
----

From `Reset_Handler` in `startup_stm32f302r8tx.s`:

----
/* Zero fill the bss segment. */
  ldr r2, =_sbss
  ldr r4, =_ebss
  movs r3, #0
  b LoopFillZerobss
. . .
----

I couldn't find any use of `__bss_start__` and `__bss_end__` so far.

Heap and Stack
--------------

Stack is at the RAM end and grows down. Heap - at the bottom (above other variables) and grows up.

----
  /* User_heap_stack section, used to check that there is enough "RAM" Ram  type memory left */
  ._user_heap_stack :
  {
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
  } >RAM
----

Remember that `_estack = ORIGIN(RAM) + LENGTH(RAM)`. After placing all other things in RAM region, moving the location counter `.` by `_Min_Heap_Size` and then by `_Min_Heap_Size` still should not go beyond the end of RAM.

Me: isn't location counter usually still _not_ at the end of RAM after the last assigment? Unless the RAM is used up exactly to the last byte.

Discard
--------

----
  /* Remove information from the compiler libraries */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }
----

The special output section name https://sourceware.org/binutils/docs/ld/Output-Section-Discarding.html#Output-Section-Discarding[`/DISCARD/`] may be used to discard input sections. Any input sections which are assigned to an output section named `/DISCARD/` are not included in the output file. https://stackoverflow.com/questions/55621981/why-do-stm32-gcc-linker-scripts-automatically-discard-all-input-sections-from-th[Reasons?]

ARM.attributes
--------------

----
  .ARM.attributes 0 : { *(.ARM.attributes) }
}
----

`readelf -a hello.elf` shows that `.ARM.attributes` doesn't go into RAM or ROM, just like `.debug...` sections:

----
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .isr_vector       PROGBITS        08000000 010000 000188 00   A  0   0  1
  [ 2] .text             PROGBITS        08000188 010188 000194 00  AX  0   0  4
  [ 3] .rodata           PROGBITS        0800031c 010324 000000 00  WA  0   0  1
  [ 4] .ARM.extab        PROGBITS        0800031c 010324 000000 00   W  0   0  1
  [ 5] .ARM              PROGBITS        0800031c 010324 000000 00   W  0   0  1
  [ 6] .preinit_array    PREINIT_ARRAY   0800031c 010324 000000 04  WA  0   0  1
  [ 7] .init_array       INIT_ARRAY      0800031c 01031c 000004 04  WA  0   0  4
  [ 8] .fini_array       FINI_ARRAY      08000320 010320 000004 04  WA  0   0  4
  [ 9] .data             PROGBITS        20000000 010324 000000 00  WA  0   0  1
  [10] .bss              NOBITS          20000000 020000 000020 00  WA  0   0  4
  [11] ._user_heap_stack NOBITS          20000020 020020 000600 00  WA  0   0  1
  [12] .ARM.attributes   ARM_ATTRIBUTES  00000000 010324 000030 00      0   0  1
  [13] .debug_info       PROGBITS        00000000 010354 000301 00      0   0  1
  [14] .debug_abbrev     PROGBITS        00000000 010655 000130 00      0   0  1
  [15] .debug_aranges    PROGBITS        00000000 010788 000050 00      0   0  8
  [16] .debug_ranges     PROGBITS        00000000 0107d8 000038 00      0   0  8
  [17] .debug_macro      PROGBITS        00000000 010810 013100 00      0   0  1
  [18] .debug_line       PROGBITS        00000000 023910 00048d 00      0   0  1
  [19] .debug_str        PROGBITS        00000000 023d9d 06622e 01  MS  0   0  1
  [20] .comment          PROGBITS        00000000 089fcb 00007b 01  MS  0   0  1
  [21] .debug_frame      PROGBITS        00000000 08a048 000080 00      0   0  4
  [22] .symtab           SYMTAB          00000000 08a0c8 000a20 10     23  67  4
  [23] .strtab           STRTAB          00000000 08aae8 00096f 00      0   0  1
  [24] .shstrtab         STRTAB          00000000 08b457 00010a 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
----

Error Reports
-------------
If you see an error in this document, please open an issue on github. Your feedback is much appreciated.

Sources
-------
- {bmas}: Building Bare-Metal ARM Systems with GNU: Part 3
- {ugls}: Understand the GNU linker script of cortex M4
- {usld}: Using ld The GNU linker: Memory layout
- {vgdb}: Customizing Memory Layout of Embedded Programs with GNU Linker Scripts
- {stov}: Understanding the linkerscript for an ARM Cortex-M microcontroller
- {eecs}: The GNU linker
- {cppe}: C++ On Embedded Systems
- {pfr7}: pomad.fr 1.3 Startup Code
- http://stefanfrings.de/stm32/stm32f3.html[stefanfrings.de] - STM32F3 Anleitung
